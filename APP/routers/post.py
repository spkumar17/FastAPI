from fastapi import status, HTTPException ,Depends ,APIRouter # type: ignore
from database import get_db
import models
from sqlalchemy.orm import Session
from schema import post_data , Retrieve_data
from typing import List

router = APIRouter(tags = ["Posts"])

@router.get("/Posts", response_model=List[Retrieve_data])
def retrieve(db: Session = Depends(get_db)): #You're injecting a database session using FastAPI's Depends.

    all_posts = db.query(models.Post).all()  #This line queries the post table (from your models module).   .all() fetches all rows as a list.
    
    if len(all_posts) > 0:
        return all_posts
    else:
        raise HTTPException(status_code=status.HTTP_204_NO_CONTENT,detail="No posts found") 


@router.post("/Posts/create", status_code=status.HTTP_201_CREATED,response_model=Retrieve_data)
def create_new_post(post : post_data, db: Session = Depends(get_db)):
                    #variable : #pyantic # db session using fastapi depends
    # new_post = models.Post(post_name=post.post_name, description= post.description,published = post.published)
    # db.add(new_post) # Adding the new object to the session
    # db.commit() # Committing to the database (actually saving the new post)
    # db.refresh(new_post)
    new_post = models.Post(**post.dict()) #When you want to create a new record (like a new post), you're not querying existing data—you're inserting a new entry. Hence, you don't need to use db.query() for creation.
    db.add(new_post)# Adding the new object to the session
    db.commit() # Committing to the database (actually saving the new post)
    db.refresh(new_post) # Refreshing the object to get the latest info (like autogenerated fields)
    
    
    return new_post

# -------------------------------------
# GET endpoint to fetch all Published posts
# -------------------------------------
@router.get("/Posts/published",response_model=List[Retrieve_data])
def get_published_Posts(db: Session = Depends(get_db)):
    
    post_Published = db.query(models.Post).filter(models.Post.published == True).all()

    
    if post_Published != 0:
        return post_Published 
    else:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,detail="No posts Published yet") 
    
@router.get("/Posts/unpublished",response_model=list[Retrieve_data])
def get_published_Posts(db: Session = Depends(get_db)):
    
    post_unPublished = db.query(models.Post).filter(models.Post.published == False).all()

    
    if post_unPublished != 0:
        return post_unPublished   
    else:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,detail="No unPublished post presents")     
      
@router.get("/Posts/{id}",response_model=Retrieve_data)
def get_Post_by_id(id :int, db: Session = Depends(get_db)):
    
    Post_by_id = db.query(models.Post).filter(models.Post.id == id).first()
    
    if Post_by_id is not None:  #In Python, psycopg2's fetchone() method returns None when no row is found. So, checking for 0 doesn't work in this case because the default return value for no result is None, not 0.
        return Post_by_id
    else:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"No Post find with id {id}")    
   
   

# # -------------------------------------
# # GET endpoint to fetch the most recent post
# # -------------------------------------
 
@router.get("/Posts/recent",response_model= Retrieve_data)
def get_recent_userinfo( db: Session = Depends(get_db)): 
    
    recent_post = (db.query(models.Post).filter(models.Post.published == True).order_by(models.Post.created_at.desc()).first())
    
    if recent_post != 0:
        return {
            "message": "recent POST info sent successfully",
            "data": recent_post
        }
        
    else:
        
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,detail="No posts Published yet") 
    
    
    

    
# # # -------------------------------------
# # # Delete endpoint to delete users by name
# # # URL format: /usersinfo/delete/{name}
# # # -------------------------------------

@router.delete("/Posts/delete/{id}",response_model= Retrieve_data)   
def delete_Post(id: int, db: Session = Depends(get_db)):

    # Query the post to check if it exists
    post_to_delete = db.query(models.Post).filter(models.Post.id == id).first()

    # If the post is not found, raise an HTTP 404 exception
    if post_to_delete is None:     
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Post {id} was not found in the list to delete")  
    
    # If the post exists, delete it
    db.delete(post_to_delete)
    db.commit()  
    
    # Return a success message with the deleted post data
    return post_to_delete
    


# # # -------------------------------------
# # # update endpoint to update users by id
# # # -------------------------------------    

@router.put("/Posts/update/{id}",response_model= Retrieve_data)
def update_Post(post: post_data, id: int, db: Session = Depends(get_db)):
    
    post_query = db.query(models.Post).filter(models.Post.id == id)
    new_post = post_query.first()

    
    if  new_post is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Post {id} was not found in list to update")
    
    post_query.update(post.dict(), synchronize_session=False)
    db.commit()

# Converts the Pydantic object to a dictionary:post_data(title="New Title", content="Updated text")  post_data.dict ===> {'title': 'New Title', 'content': 'Updated text'}
# Translates to SQL: UPDATE posts SET title='New Title', content='Updated text' WHERE id=3
# synchronize_session=False skips syncing in-memory objects, improving performance
# db.commit() applies and saves the update permanently to the database

    return  post_query.first() # this will fetch the newly updated post after saving   post_query.first()

# Explanationn
# post_query = db.query(models.Post).filter(models.Post.id == id)
# → This creates a SQLAlchemy query object to find a post with the given ID — but doesn’t execute it yet.

# post = post_query.first()
# → Executes the query to fetch the actual post from the database and stores it in the post variable (an instance of the ORM model, not the Pydantic model).

# post_query.update(post_data.dict(), synchronize_session=False)
# → Updates the database row with the new values provided in the request body (post_data, a Pydantic model), converting it to a dictionary with .dict().

# db.commit()
# → Permanently saves the updated values to the database.    

